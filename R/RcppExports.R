# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Multivariate Normal H[x]
#' 
#' Calculate and return the entropy for multivariate distribution
#' with supplied covariance matrix.
#' 
#' @param S Covariance matrix 
mvn_entropy <- function(S) {
    .Call(`_varapproxr_mvn_entropy`, S)
}

#' Calculate E[||y - Xb||^2] for b ~ MVN(mu, Sigma)
#'
#' @param yty Statistic y'y
#' @param Xty Statistic X'y
#' @param XtX Statistic X'X
#' @param mu Variational mean mu
#' @param Sigma Variational variance Sigma
dot_y_minus_Xb <- function(yty, Xty, XtX, mu, Sigma) {
    .Call(`_varapproxr_dot_y_minus_Xb`, yty, Xty, XtX, mu, Sigma)
}

#' Inverse Gamma H[x]
#' 
#' Calculate H[x] where x ~ IG(a,b)
#' 
#' @param a shape
#' @param b scale 
ig_entropy <- function(a, b) {
    .Call(`_varapproxr_ig_entropy`, a, b)
}

#' Inverse Gamma E[x]
#' 
#' Calculate and return the expected value for x ~ IG(a,b).
#' 
#' @param a shape
#' @param b scale 
ig_E <- function(a, b) {
    .Call(`_varapproxr_ig_E`, a, b)
}

#' Inverse Gamma E[1/x]
#' 
#' Calculate and return E[1/x] where x ~ IG(a,b).
#' 
#' @param a shape
#' @param b scale 
ig_E_inv <- function(a, b) {
    .Call(`_varapproxr_ig_E_inv`, a, b)
}

#' Inverse Gamma E[log(x)]
#' 
#' Calculate and return E[log(x)] where x ~ IG(a,b).
#' 
#' @param a shape
#' @param b scale 
ig_E_log <- function(a, b) {
    .Call(`_varapproxr_ig_E_log`, a, b)
}

#' E_q[ln p(x)] where x ~ IG(a0, b0) and q(x) = IG(x | a, b)
#'
#' @param a0 Inverse gamma prior parameter
#' @param b0 Inverse gamma prior parameter
#' @param a Inverse gamma variational parameter
#' @param b Inverse gamma variational parameter
ig_E_lpdf <- function(a0, b0, a, b) {
    .Call(`_varapproxr_ig_E_lpdf`, a0, b0, a, b)
}

#' Woodbury matrix identity
#'
#' (A + BCD)^{-1}
#' 
#' @param A mat A
#' @param B mat B
#' @param C mat C
#' @param D mat D
woodbury <- function(A, B, C, D) {
    .Call(`_varapproxr_woodbury`, A, B, C, D)
}

#' Convert arma::vec to Rcpp::NumericVector
#' 
#' @param x A vector
arma2vec <- function(x) {
    .Call(`_varapproxr_arma2vec`, x)
}

#' Construct block-diagonal matrix from list of matrices
#' 
#' @param x A list of matrices
blockDiag <- function(x) {
    .Call(`_varapproxr_blockDiag`, x)
}

#' Right-bind columns of matrices from in list.
#' 
#' @param x A list of matrices
bind_cols <- function(x) {
    .Call(`_varapproxr_bind_cols`, x)
}

#' Evaluate standard normal cdf for matrix of variates
#' 
#' @param m A matrix of variates 
pnorm_mat <- function(m) {
    .Call(`_varapproxr_pnorm_mat`, m)
}

#' Evaluate standard normal density for matrix of variates
#' 
#' @param m A matrix of variates 
dnorm_mat <- function(m) {
    .Call(`_varapproxr_dnorm_mat`, m)
}

#' Mean-field variational inference for a normal linear model.
#' 
#' @param X The design matrix
#' @param y The response vector
#' @param mu0 The prior mean for beta
#' @param Sigma0 The prior covariance for beta
#' @param a0 The scale hyper-parameter
#' @param b0 The shape hyper-parameter
#' @param prior The prior to be used, `1` - inverse-gamma(a0,b0), `2`- half-t(a0,b0)
#' @param tol Tolerance for convergence of the elbo
#' @param maxiter Maximum number of iterations allowed
#' @param verbose Print trace of the lower bound to console. Default is \code{FALSE}.
#' @return v A list of relevant outputs
#' 
#' @export
vb_lm <- function(X, y, mu0, Sigma0, a0 = 1e-2, b0 = 1e-2, prior = 1L, tol = 1e-8, maxiter = 100L, verbose = FALSE) {
    .Call(`_varapproxr_vb_lm`, X, y, mu0, Sigma0, a0, b0, prior, tol, maxiter, verbose)
}

#' Update mean-field variational inference for a normal linear model.
#' 
#' @param vb_fit A previous fit
#' @param X The new design matrix
#' @param y The new response vector
#' @param tol Tolerance for convergence of the elbo
#' @param maxiter Maximum number of iterations allowed
#' @param verbose Print trace of the lower bound to console. Default is \code{FALSE}.
#' @return v A list of relevant outputs
#' 
#' @export
update_vb_lm <- function(vb_fit, X, y, tol = 1e-8, maxiter = 100L, verbose = FALSE) {
    .Call(`_varapproxr_update_vb_lm`, vb_fit, X, y, tol, maxiter, verbose)
}

#' Variational Bayes for linear mixed model.
#' 
#' Variational approximation for linear mixed model assuming Gaussian distribution priors on fixed and grouped effects.
#' Priors on the variance parameters are Scaled-Inverse-Wishart distributions.
#' 
#' @param y The response vector
#' @param X The design matrix
#' @param Zlist Collection of group design matrices
#' @param J First dimension of each Z in Zlist (e.g. number of subjects)
#' @param R Second dimension of each Z in Zlist (e.g. number of variables, intercept and slope would be R = 2)
#' @param mu_beta0 The prior mean for beta
#' @param Sigma_beta0 The prior covariance for beta
#' @param xi_sigma ...
#' @param Lambda_sigma ...
#' @param xi_k ...
#' @param Lambda_k ...
#' @param tol Tolerance level
#' @param maxiter Maximum iterations
#' @param verbose Print trace of the lower bound to console. Default is \code{FALSE}.
#' @param trace Print a trace of `mu` to console.
#' @return A list containing:
#' \describe{
#'   \item{converged}{Indicator for algorithm convergence.}
#'   \item{elbo}{Vector of the ELBO sequence.} 
#'   \item{mu}{The optimised value of mu.}
#'   \item{Sigma}{The optimised value of Sigma.}
#' }
#' @export
vb_lmm <- function(y, X, Zlist, J, R, mu_beta0, Sigma_beta0, xi_sigma, Lambda_sigma, xi_k, Lambda_k, tol = 1e-8, maxiter = 100L, verbose = FALSE, trace = FALSE) {
    .Call(`_varapproxr_vb_lmm`, y, X, Zlist, J, R, mu_beta0, Sigma_beta0, xi_sigma, Lambda_sigma, xi_k, Lambda_k, tol, maxiter, verbose, trace)
}

#' Variational Bayes for linear mixed model.
#' 
#' 
#' @param X The design matrix
#' @param Z Group design matrix
#' @param y The response vector
#' @param mu_beta The prior mean for beta
#' @param sigma_beta The prior covariance for beta
#' @param mu Initial value for mu
#' @param sigma Initial value for sigma
#' @param Aeps The prior shape for sigma_eps
#' @param Beps The prior scale for sigma_eps
#' @param Au The prior shape for sigma_u
#' @param Bu The prior scale for sigma_u
#' @param Bqeps The intial value for Bqeps
#' @param Bqu The initial value for Bqu
#' @param tol Tolerance level
#' @param maxiter Maximum iterations
#' @param verbose Print trace of the lower bound to console. Default is \code{FALSE}.
#' @param trace Print a trace of `mu` to console.
#' @return A list containing:
#' \describe{
#'   \item{converged}{Indicator for algorithm convergence.}
#'   \item{elbo}{Vector of the ELBO sequence.} 
#'   \item{mu}{The optimised value of mu.}
#'   \item{Sigma}{The optimised value of Sigma.}
#' }
#' 
#' @examples
#' library(nlme)
#' X <- model.matrix( ~ age + factor(Sex, levels = c("Female", "Male")), data = Orthodont)
#' Z <- kronecker(diag(1, 27), rep(1, 4))
#' y <- Orthodont$distance
#' mu0 <- rep(0, ncol(X))
#' S0 <- diag(1e8, ncol(X))
#' mu <- rep(0, ncol(X) + ncol(Z))
#' S <- diag(1, ncol(X) + ncol(Z))
#' A <- 1/100
#' B <- 1/100
#' fit <- vb_lmm_randint(X, Z, y, mu0, S0, mu, S, A, B, A, B, verbose = TRUE)
#' 
#' @export
vb_lmm_randint <- function(X, Z, y, mu_beta, sigma_beta, mu, sigma, Aeps = 1.0, Beps = 1.0, Au = 1.0, Bu = 1.0, Bqeps = 1.0, Bqu = 1.0, tol = 1e-8, maxiter = 100L, verbose = FALSE, trace = FALSE) {
    .Call(`_varapproxr_vb_lmm_randint`, X, Z, y, mu_beta, sigma_beta, mu, sigma, Aeps, Beps, Au, Bu, Bqeps, Bqu, tol, maxiter, verbose, trace)
}

#' Perform Jaakkola-Jordan update of variational parameters
#' 
#' @param X The design matrix
#' @param y The response vector
#' @param eta1 The current value of 1st natural parameter
#' @param eta2 The current value of the 2nd natural parameter
#' @param eta1_p The prior value of the 1st natural parameter
#' @param eta2_p The prior value of the 2nd natural parameter
jaakkola_jordan <- function(X, y, eta1, eta2, eta1_p, eta2_p) {
    .Call(`_varapproxr_jaakkola_jordan`, X, y, eta1, eta2, eta1_p, eta2_p)
}

#' Perform Jaakkola-Jordan update of variational parameters
#' 
#' @param X The design matrix
#' @param y The response vector
#' @param n The trial vector
#' @param eta1 The current value of 1st natural parameter
#' @param eta2 The current value of the 2nd natural parameter
#' @param eta1_p The prior value of the 1st natural parameter
#' @param eta2_p The prior value of the 2nd natural parameter
jaakkola_jordan_n <- function(X, y, n, eta1, eta2, eta1_p, eta2_p) {
    .Call(`_varapproxr_jaakkola_jordan_n`, X, y, n, eta1, eta2, eta1_p, eta2_p)
}

#' Perform Saul-Jordan update of variational parameters
#' 
#' @param X The design matrix
#' @param y The response vector
#' @param eta1 The current value of 1st natural parameter
#' @param eta2 The current value of the 2nd natural parameter
#' @param eta1_p The prior value of the 1st natural parameter
#' @param eta2_p The prior value of the 2nd natural parameter
#' @param omega1 The current value of the Omega1 variational parameter
saul_jordan <- function(X, y, eta1, eta2, eta1_p, eta2_p, omega1) {
    .Call(`_varapproxr_saul_jordan`, X, y, eta1, eta2, eta1_p, eta2_p, omega1)
}

#' Perform Saul-Jordan update of variational parameters
#' 
#' @param X The design matrix
#' @param y The response vector
#' @param n The trial vector
#' @param eta1 The current value of 1st natural parameter
#' @param eta2 The current value of the 2nd natural parameter
#' @param eta1_p The prior value of the 1st natural parameter
#' @param eta2_p The prior value of the 2nd natural parameter
#' @param omega1 The current value of the Omega1 variational parameter
saul_jordan_n <- function(X, y, n, eta1, eta2, eta1_p, eta2_p, omega1) {
    .Call(`_varapproxr_saul_jordan_n`, X, y, n, eta1, eta2, eta1_p, eta2_p, omega1)
}

#' Perform Knowles-Minka-Wand update of variational parameters
#' 
#' @param X The design matrix
#' @param y The response vector
#' @param eta1 The current value of 1st natural parameter
#' @param eta2 The current value of the 2nd natural parameter
#' @param eta1_p The prior value of the 1st natural parameter
#' @param eta2_p The prior value of the 2nd natural parameter
#' @param MS_p The 
#' @param MS_s The
knowles_minka_wand <- function(X, y, eta1, eta2, eta1_p, eta2_p, MS_p, MS_s) {
    .Call(`_varapproxr_knowles_minka_wand`, X, y, eta1, eta2, eta1_p, eta2_p, MS_p, MS_s)
}

#' Perform Knowles-Minka-Wand update of variational parameters
#' 
#' @param X The design matrix
#' @param y The response vector
#' @param n The trials vector
#' @param eta1 The current value of 1st natural parameter
#' @param eta2 The current value of the 2nd natural parameter
#' @param eta1_p The prior value of the 1st natural parameter
#' @param eta2_p The prior value of the 2nd natural parameter
#' @param MS_p The 
#' @param MS_s The
knowles_minka_wand_n <- function(X, y, n, eta1, eta2, eta1_p, eta2_p, MS_p, MS_s) {
    .Call(`_varapproxr_knowles_minka_wand_n`, X, y, n, eta1, eta2, eta1_p, eta2_p, MS_p, MS_s)
}

#' Perform variational inference for logistic regression model
#' 
#' @param X The design matrix
#' @param y The response vector
#' @param mu0 The prior mean for beta paramter
#' @param Sigma0 The prior variance for beta parameter
#' @param mu_init Initial value for \code{mu} for optimisation.
#' @param Sigma_init Initial value for \code{Sigma} for optimisation.
#' @param tol The tolerance level to assess convergence
#' @param maxiter The maximum number of iterations
#' @param maxiter_jj The maximum number of Jaakkola-Jordan iterations to initialise estimation
#' @param alg The algorithm used for final estimation of variational parameters. 
#' @param verbose Print trace of the lower bound to console. Default is \code{FALSE}.
#' Must be one of "jj", "sj", "kmw".
#' 
#' @export
vb_logistic <- function(X, y, mu0, Sigma0, mu_init, Sigma_init, tol = 1e-8, maxiter = 1000L, maxiter_jj = 25L, alg = "jj", verbose = FALSE) {
    .Call(`_varapproxr_vb_logistic`, X, y, mu0, Sigma0, mu_init, Sigma_init, tol, maxiter, maxiter_jj, alg, verbose)
}

#' Variational inference for binomial logistic regression model
#' 
#' This is an experimental function to perform variational inference
#' for binomial logistic regression models.
#' 
#' @param X The design matrix
#' @param y The response vector
#' @param n The trial vector
#' @param mu0 The prior mean for beta paramter
#' @param Sigma0 The prior variance for beta parameter
#' @param mu_init Initial value for \code{mu} for optimisation.
#' @param Sigma_init Initial value for \code{Sigma} for optimisation.
#' @param tol The tolerance level to assess convergence
#' @param maxiter The maximum number of iterations
#' @param maxiter_jj The maximum number of Jaakkola-Jordan 
#'   iterations to initialise estimation
#' @param alg The algorithm used for final estimation 
#'   of variational parameters. 
#'   Must be one of \code{jj}, \code{sj}, or \code{kmw}.
#' @param verbose Print trace of the lower bound to console. Default is \code{FALSE}.
#' 
#' @section Details:
#'   By default, the algorithm always intialises with Jaakkola-Jordan updates
#'   until convergence or \code{maxiter_jj}.
#' 
#' @return A list containing:
#' \describe{
#'   \item{\code{converged}}{Indicator for algorithm convergence.}
#'   \item{\code{jj_converged}}{Indicator for convergence of initial Jaakkola-Jordan iterations.}
#'   \item{\code{elbo}}{Vector of the ELBO sequence.} 
#'   \item{\code{mu}}{The optimised value of mu.}
#'   \item{\code{Sigma}}{The optimised value of Sigma.}
#' }
#' @export
vb_logistic_n <- function(X, y, n, mu0, Sigma0, mu_init, Sigma_init, tol = 1e-8, maxiter = 1000L, maxiter_jj = 25L, alg = "jj", verbose = FALSE) {
    .Call(`_varapproxr_vb_logistic_n`, X, y, n, mu0, Sigma0, mu_init, Sigma_init, tol, maxiter, maxiter_jj, alg, verbose)
}

#' Variational Bayes for logistic mixed model.
#' 
#' 
#' @param X The design matrix
#' @param Z Group design matrix
#' @param y The response vector
#' @param mu_beta The prior mean for beta
#' @param sigma_beta The prior covariance for beta
#' @param mu Initial value for mu
#' @param sigma Initial value for sigma
#' @param Au The prior shape for u
#' @param Bu The prior scale for u
#' @param Bqu The initial value for Bqu
#' @param tol Tolerance level
#' @param maxiter Maximum iterations
#' @param verbose Print trace of the lower bound to console. Default is \code{FALSE}.
#' @return A list containing:
#' \describe{
#'   \item{converged}{Indicator for algorithm convergence.}
#'   \item{elbo}{Vector of the ELBO sequence.} 
#'   \item{mu}{The optimised value of mu.}
#'   \item{sigma}{The optimised value of sigma.}
#' }
#' 
#' @export
vb_glmm <- function(X, Z, y, mu_beta, sigma_beta, mu, sigma, Au = 1.0, Bu = 1.0, Bqu = 1.0, tol = 1e-8, maxiter = 100L, verbose = FALSE) {
    .Call(`_varapproxr_vb_glmm`, X, Z, y, mu_beta, sigma_beta, mu, sigma, Au, Bu, Bqu, tol, maxiter, verbose)
}

#' Perform mean-field variational inference for 
#' a Poisson regression model.
#' 
#' @param X The design matrix
#' @param y The response vector
#' @param n The offset term
#' @param mu0 The prior mean for beta
#' @param Sigma0 The prior covariance for beta
#' @param tol Tolerance for convergence of the elbo
#' @param maxiter Maximum number of iterations allowed
#' @param verbose Print trace of the lower bound to console. Default is \code{FALSE}.
#' @return v A list of relevant outputs
#' 
#' @export
vb_pois_reg <- function(X, y, n, mu0, Sigma0, tol = 1e-8, maxiter = 100L, verbose = FALSE) {
    .Call(`_varapproxr_vb_pois_reg`, X, y, n, mu0, Sigma0, tol, maxiter, verbose)
}

#' Perform mean-field variational inference for 
#' a Poisson mixed-effects regression model.
#' 
#' @param X The design matrix
#' @param Zlist The random effect design matrices
#' @param y The response vector
#' @param n The offset term
#' @param mu0 The prior mean for beta
#' @param Sigma0 The prior covariance for beta
#' @param a0 Half-Cauchy scale hyper-parameter
#' @param tol Tolerance for convergence of the elbo
#' @param maxiter Maximum number of iterations allowed
#' @param verbose Print trace of the lower bound to console. Default is \code{FALSE}.
#' @return v A list of relevant outputs
#' 
#' @export
vb_pois_mm <- function(X, Zlist, y, n, mu0, Sigma0, a0, tol = 1e-8, maxiter = 100L, verbose = FALSE) {
    .Call(`_varapproxr_vb_pois_mm`, X, Zlist, y, n, mu0, Sigma0, a0, tol, maxiter, verbose)
}

#' Normal parametric variational Bayes for Exponential PH Model.
#' 
#' Perform Normal approximation variational inference for 
#' proportional-hazards model with exponential base.
#' 
#' @param X The design matrix
#' @param y The response vector
#' @param v The censoring vector
#' @param mu0 The prior mean for beta
#' @param Sigma0 The prior covariance for beta
#' @param tol The tolerance for convergence of ELBO
#' @param maxiter The maximum number of iterations allowed
#' @param verbose Print trace of the lower bound to console. Default is \code{FALSE}.
#' @return A list containing:
#' \describe{
#'   \item{converged}{Indicator for algorithm convergence.}
#'   \item{elbo}{Vector of the ELBO sequence.} 
#'   \item{mu}{The optimised value of mu.}
#'   \item{Sigma}{The optimised value of Sigma.}
#' }
#' 
#' @export
ph_exponential <- function(X, y, v, mu0, Sigma0, tol = 1e-8, maxiter = 100L, verbose = FALSE) {
    .Call(`_varapproxr_ph_exponential`, X, y, v, mu0, Sigma0, tol, maxiter, verbose)
}

#' Calculate entropy for Gaussian density
#' 
#' @param eta Natural parameter
GaussianEntropy <- function(eta) {
    .Call(`_varapproxr_GaussianEntropy`, eta)
}

#' Calculate vec^(-1)
#' 
#' @param v A vector of dimension d^2 by 1
inv_vectorise <- function(v) {
    .Call(`_varapproxr_inv_vectorise`, v)
}

#' Calculate vech of a matrix
#'
#' @param X A square matrix of dimension d by d
vech <- function(X) {
    .Call(`_varapproxr_vech`, X)
}

#' Calculate inverse of vech for a vector
#'
#' @param v A vector of dimension d(d+1)/2 of lower triangular elements
inv_vech <- function(v) {
    .Call(`_varapproxr_inv_vech`, v)
}

#' Calculate
#' 
#' @param v A (d + d*d) x 1 vector
#' @param Q A d x d matrix
#' @param r A d x 1 vector
#' @param s A double
G_VMP <- function(v, Q, r, s) {
    .Call(`_varapproxr_G_VMP`, v, Q, r, s)
}

#' Gaussian prior fragment update
#' 
#' @param mu The prior mean
#' @param Sigma The prior variance
GaussianPriorFragment <- function(mu, Sigma) {
    .Call(`_varapproxr_GaussianPriorFragment`, mu, Sigma)
}

#' Inverse-Gamma prior fragment update
#' 
#' @param a Shape parameter
#' @param b Scale parameter
InverseGammaPriorFragment <- function(a, b) {
    .Call(`_varapproxr_InverseGammaPriorFragment`, a, b)
}

#' Inverse Wishart prior fragment update
#' 
#' @param xi The prior shape
#' @param Lambda The prior symmetric positive definite matrix
InverseWishartPriorFragment <- function(xi, Lambda) {
    .Call(`_varapproxr_InverseWishartPriorFragment`, xi, Lambda)
}

#' Inverse G-Wishart prior fragment update
#' 
#' @param G The graph matrix
#' @param xi The prior shape
#' @param Lambda The prior symmetric positive definite matrix
InverseGWishartPriorFragment <- function(G, xi, Lambda) {
    .Call(`_varapproxr_InverseGWishartPriorFragment`, G, xi, Lambda)
}

#' Iterated Inverse G-Wishart fragment update
#' 
#' @param G The graph matrix.
#' @param xi The prior shape.
#' @param eta1_in A d + 1 x 1 vector.
#' @param eta2_in A d + 1 x 1 vector.
IteratedInverseGWishartFragment <- function(G, xi, eta1_in, eta2_in) {
    .Call(`_varapproxr_IteratedInverseGWishartFragment`, G, xi, eta1_in, eta2_in)
}

#' Gaussian likelihood fragment update
#' 
#' @param n Number of rows
#' @param XtX Statistic 1
#' @param Xty Statistic 2
#' @param yty Statistic 3
#' @param eta1_in Natural parameter 1
#' @param eta2_in Natural parameter 2
GaussianLikelihoodFragment <- function(n, XtX, Xty, yty, eta1_in, eta2_in) {
    .Call(`_varapproxr_GaussianLikelihoodFragment`, n, XtX, Xty, yty, eta1_in, eta2_in)
}

#' Gaussian transform natural parameters to E[T(X)] parameters.
#' 
#' @param eta The natural parameter vector.
#' 
ExpectationGaussianSufficientStatistics <- function(eta) {
    .Call(`_varapproxr_ExpectationGaussianSufficientStatistics`, eta)
}

#' Gaussian transform natural parameters to E[T(X)] parameters.
#' 
#' @param eta The natural parameter vector.
#' 
GaussianCommonParameters <- function(eta) {
    .Call(`_varapproxr_GaussianCommonParameters`, eta)
}

#' Inverse-G-Wishart transform natural parameters to E[T(X)] parameters.
#' 
#' @param G The graph.
#' @param eta The natural parameter vector.
#' 
ExpectationInverseGWishartSufficientStatistics <- function(G, eta) {
    .Call(`_varapproxr_ExpectationInverseGWishartSufficientStatistics`, G, eta)
}

#' Inverse-G-Wishart Common parameters
#' 
#' @param eta The natural parameter vector.
#' 
InverseGWishartCommonParameters <- function(eta) {
    .Call(`_varapproxr_InverseGWishartCommonParameters`, eta)
}

#' Variational Message Passing for Normal linear model.
#' 
#' @param n Number of rows
#' @param X The design matrix n by d.
#' @param y The observation vector n by 1.
#' @param mu0 The prior mean on coefficients
#' @param Sigma0 The prior variance on coefficients
#' @param A The prior scale on variance
#' @param maxiter The maximum number of iterations
#' @param tol Tolerance for convergence
#' @param verbose Print trace of the ELBO
vmp_lm <- function(n, X, y, mu0, Sigma0, A, maxiter = 1e2L, tol = 1e-10, verbose = TRUE) {
    .Call(`_varapproxr_vmp_lm`, n, X, y, mu0, Sigma0, A, maxiter, tol, verbose)
}

